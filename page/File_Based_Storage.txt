<div class="validatepage"><span>Validation required.</span><br />
<p>This page contains possibly incorrect or incomplete information. Further testing is required.<br /><br />This tutorial has several problems:
</p>
<ul><li> Doesn't explain or provide alternatives to data serialization such as <a href="/page/Category_colon_util" title="Category:util">util</a>.<a href="/page/util/TableToJSON" title="util/TableToJSON">TableToJSON</a>
</li><li> SteamID() during the <a href="/page/Category_colon_GM_Hooks" title="Category:GM Hooks">GM</a>:<a href="/page/GM/ShutDown" title="GM/ShutDown">ShutDown</a> hook can return an empty string and the code doesn't handle this
</li><li> Saving code doesn't explicitly define argument order which can cause data to write in the wrong order potentially resulting in data corruption</div>
</li></ul>
<h1> <span class="mw-headline" id="Introduction"> Introduction </span></h1>
<p>Data Storage is what we use when we want data to persist through map changes and server restarts.
</p>
<table cellspacing="0" class="gmodwiki_note">
<tr>
<td>NOTE
</td>
<td>
<p>Never trust the client with data. Only store, save, change, and load data from the server. If you require data on the client - Send it from the server
</p>
</td></tr></table>
<p>For the sake of understanding the tutorial, imagine data storage as a table distribution of everything we want saved. Ex:
</p>
<table class="wikitable">
<tr>
<th> SteamID
</th>
<th> Time Played
</th>
<th> Deaths
</th></tr>
<tr>
<td> STEAM_0:0:000001
</td>
<td> 10
</td>
<td> 0
</td></tr>
<tr>
<td> STEAM_0:0:000002
</td>
<td> 300
</td>
<td> 3
</td></tr>
<tr>
<td> STEAM_0:0:000003
</td>
<td> 80
</td>
<td> 1
</td></tr>
<tr>
<td colspan="3"> Etc...
</td></tr></table>
<p>Each column holds a variable for a player. The first column is the key, how we differentiate different players (A player's SteamID is a good choice for the key as it's unique). And so each row represents the data of a single player
</p><p>There are multiple ways of storing data in Garry's Mod. In this tutorial, we will go over File Based Storage
</p>
<h1> <span class="mw-headline" id="About"> About </span></h1>
<p>Text files are a simple and effective tool that can be used to store data. File Based Storage does not require any external modules, it relies solely on the <a href="/page/Category_colon_file" title="Category:file">file library</a>, and it's pretty straightforward. For these reasons, it is the recommended method for beginners.
</p>
<h1> <span class="mw-headline" id="Delimiter-separated_values"> Delimiter-separated values </span></h1>
<p>The most common and simplest method of storing data in text files is to split the string using key-characters, separating each player with a key character, and the different variables stored with another key character.
</p><p>We will now make a File Based Storage system that tracks the player's playing time on the server and their total deaths. Our key characters will be:
</p>
<ul><li> <b>"\n"</b> - To separate between players. New line = new player
</li><li> <b>;</b> - To separate each stored variable.
</li></ul>
<p>Our file, that will hold the data (e.g. player_data.txt) will look something like this:
</p>
<pre><code data-language="lua">SteamID;Playtime;Deaths
SteamID;Playtime;Deaths
...</code></pre>
<p>And with some values:
</p>
<pre><code data-language="lua">STEAM_0:0:0000001;10;0
STEAM_0:0:0000002;300;3
STEAM_0:0:0000003;80;2</code></pre>
<p>The first thing we'll do is properly load the data from the text file when the server starts.
</p><p>What we're doing is creating a table with SteamIDs as keys, and whose values are playtime and deaths
</p>
<pre><code data-language="lua">local PlayerData = {}
local function LoadPlayerData()
	local data = file.Read( &quot;player_data.txt&quot;, &quot;DATA&quot; ) -- Read the file
	if not data then return end -- File doesn't exist
	
	data = string.Split( data, &quot;\n&quot; ) -- Split the data into lines (Each line represents a palyer)
	for _, line in ipairs( data ) do -- Iterate through each line
		local args = string.Split( line, &quot;;&quot; ) -- Split the line into variables
		if ( #args &lt; 3 ) then continue end -- The data from the file contains unexpected amount of entries, skip the line
		local id = args[1] -- Store the key variable, for comfortability's sake
		if not id then return end -- Something is wrong
		PlayerData[id] = {} -- Create the table
		-- Update our PlayerData table
		PlayerData[id].playtime = args[2]
		PlayerData[id].deaths = args[3]
	end
end

LoadPlayerData() -- Load the data once the server launches</code></pre>
<p>Next, we will load the data of each player as they join.
</p>
<pre><code data-language="lua">hook.Add( &quot;PlayerInitialSpawn&quot;, &quot;LoadPlayerData&quot;, function( ply )
	local sid = ply:SteamID()
	local data = PlayerData[sid]
	if data then -- If the player exists in the database, load his data
		ply.playtime = data.playtime
		ply.deaths = data.deaths
	else -- If the player doesn't exist in the database, reset the data
		ply.playtime = 0
		ply.deaths = 0
	end
end )</code></pre>
<p>Lastly, update the data on the server whenever a player disconnects, and write it whenever the map changes or the server restarts.
</p>
<pre><code data-language="lua">local function SavePlayerData( ply )
	local sid = ply:SteamID()
	if not PlayerData[sid] then PlayerData[sid] = {} end
	
	PlayerData[sid].playtime = ply.playtime
	PlayerData[sid].deaths = ply.deaths
end

--[[
	We only need to write the data into the file once - when the map changes or the server restarts
	However, we need to update our PlayerData table (Which is a sorted copy of our text file) when a player disconnects
--]]

hook.Add( &quot;PlayerDisconnected&quot;, &quot;SavePlayerData1&quot;, SavePlayerData )

hook.Add( &quot;ShutDown&quot;, &quot;SavePlayerData2&quot;, function()
	for _, ply in ipairs( player.GetAll() ) do
		SavePlayerData( ply ) -- Save the data of all players currently connected
	end
	
	-- Lastly, write our txt file
	local str = &quot;&quot; -- This is the string we will write to the file
	for id, args in pairs( PlayerData ) do
		str = str .. id -- The first stored value is the identifier
		for _, arg in pairs( args ) do -- Add each stored variable in our table to the string
			str = str .. &quot;;&quot; .. arg
		end
		
		str = str .. &quot;\n&quot; -- Before moving on to the next player, start a new line
	end
	
	file.Write( &quot;player_data.txt&quot;, str )
end )</code></pre>
<p>Of course, if we actually want these values to be correct, we should have a code that updates them
</p>
<pre><code data-language="lua">hook.Add( &quot;PostPlayerDeath&quot;, &quot;UpdatePlayerDataDeaths&quot;, function( ply )
	ply.deaths = ply.deaths + 1
end )

timer.Create( &quot;UpdatePlayerDataTime&quot;, 10, 0, function() -- Repeat every 10 seconds because accuracy isn't a necessity when counting playtime
	for _, ply in ipairs( player.GetAll() ) do
		ply.playtime = ply.playtime + 10 -- Again, accuracy isn't a necessity when counting playtime.
		-- If we wanted to be accurate, we'd have to use The TimeConnected function for the first occurance
	end
end )</code></pre>
<p>The final product:
</p>
<pre><code data-language="lua">local PlayerData = {}
local function LoadPlayerData()
	local data = file.Read( &quot;player_data.txt&quot;, &quot;DATA&quot; )
	if not data then return end
	
	data = string.Split( data, &quot;\n&quot; )
	for _, line in ipairs( data ) do
		local args = string.Split( line, &quot;;&quot; )
		if ( #args &lt; 3 ) then continue end
		local id = args[1]
		if not id then return end
		PlayerData[id] = {}
		PlayerData[id].playtime = args[2]
		PlayerData[id].deaths = args[3]
	end
end

LoadPlayerData()

hook.Add( &quot;PlayerInitialSpawn&quot;, &quot;LoadPlayerData&quot;, function( ply )
	local sid = ply:SteamID()
	local data = PlayerData[sid]
	if data then
		ply.playtime = data.playtime
		ply.deaths = data.deaths
	else 
		ply.playtime = 0
		ply.deaths = 0
	end
end )

local function SavePlayerData( ply )
	local sid = ply:SteamID()
	if not PlayerData[sid] then PlayerData[sid] = {} end
	
	PlayerData[sid].playtime = ply.playtime
	PlayerData[sid].deaths = ply.deaths
end


hook.Add( &quot;PlayerDisconnected&quot;, &quot;SavePlayerData1&quot;, SavePlayerData )
hook.Add( &quot;ShutDown&quot;, &quot;SavePlayerData2&quot;, function()
	for _, ply in ipairs( player.GetAll() ) do
		SavePlayerData( ply )
	end
	
	local str = &quot;&quot;
	for id, args in pairs( PlayerData ) do
		str = str .. id
		for _, arg in pairs( args ) do
			str = str .. &quot;;&quot; .. arg
		end
		
		str = str .. &quot;\n&quot;
	end
	
	file.Write( &quot;player_data.txt&quot;, str )
end )

hook.Add( &quot;PostPlayerDeath&quot;, &quot;UpdatePlayerDataDeaths&quot;, function( ply )
	ply.deaths = ply.deaths + 1
end )

timer.Create( &quot;UpdatePlayerDataTime&quot;, 10, 0, function()
	for _, ply in ipairs( player.GetAll() ) do
		ply.playtime = ply.playtime + 10
	end
end )</code></pre>
<table cellspacing="0" class="gmodwiki_note">
<tr>
<td>NOTE
</td>
<td>
<p>When using Delimiter-Separated Values, <b>do not save any data that the user can edit</b>. For example, in the above example, if a player with the username <b>;\n\n;;\n</b> joined the server, and we were to store his username, it would break the code
</p>
</td></tr></table>
<table cellspacing="0" class="gmodwiki_note">
<tr>
<td>NOTE
</td>
<td>
<p>Alternatively, you can convert your string to a series of numbers, or a sterilized string that matches your key characters. However, it is recommended to avoid doing this, and use SQL instead
</p>
</td></tr></table>


