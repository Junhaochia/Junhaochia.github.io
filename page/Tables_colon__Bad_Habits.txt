<p>Manipulating tables in an inefficient way is so common that instead of complaining, I am publishing a guide.
</p><p>Feel free to share this guide all around the Lua programming community, especially beginners!
</p><p>The examples below do not necessarily work as they are shown. They are only given for a teaching purpose.
</p>
<h2> <span class="mw-headline" id="Example_1"> Example 1 </span></h2>
<p><i>Description:</i> This example restricts the vehicle classes usable by some teams.
</p><p>This example shows what not to do because using useless loops is inefficient.
</p>
<pre><code data-language="lua">-- EXAMPLE OF BAD CODE: DO NOT USE

local RestrictedTeams = {
	TEAM_COOK,
	TEAM_CITIZEN,
	TEAM_MOB,
}

local AllowedVehicles = {
	&quot;prop_vehicle_jeep&quot;,
	&quot;prop_vehicle_airboat&quot;,
	&quot;prop_vehicle_custom1&quot;,
	&quot;prop_vehicle_custom4&quot;,
	&quot;prop_vehicle_custom5&quot;
}

hook.Add( &quot;CanPlayerEnterVehicle&quot;, &quot;restrict vehicles&quot;, function( ply, veh )
	if table.HasValue( RestrictedTeams, ply:Team() ) then
		if not table.HasValue( AllowedVehicles, veh:GetClass() ) then
			return false
		end
	end
end )</code></pre>
<p>Now let's expand every call of <a href="/page/Category_colon_table" title="Category:table">table</a>.<a href="/page/table/HasValue" title="table/HasValue">HasValue</a> as a loop. This basically translates the function to its meaning.
</p>
<pre><code data-language="lua">-- EXPANSION OF BAD CODE: DO NOT USE

hook.Add( &quot;CanPlayerEnterVehicle&quot;, &quot;restrict vehicles&quot;, function( ply, veh )
	local Value = ply:Team()
	local HasValue = false
	for k, v in pairs( RestrictedTeams ) do
		if ( v == Value ) then
			HasValue = true
			break
		end
	end
	if HasValue then
		local Value = veh:GetClass()
		local HasValue = false
		for k, v in pairs( AllowedVehicles ) do
			if ( v == Value ) then
				HasValue = true
				break
			end
		end
		if not HasValue then
			return false
		end
	end
end )</code></pre>
<p>Now you see clearly that you loop over tables by using <a href="/page/Category_colon_table" title="Category:table">table</a>.<a href="/page/table/HasValue" title="table/HasValue">HasValue</a>. In 99% of situations, checking the presence of a <b>value</b> in a table is a waste of CPU time. Using this method is very bad for small tables, and it is insane for large tables.
</p><p>The next code shows how to make your tables efficient, with no loop and no function calls! It only relies on the presence of a <b>key</b> (never a <b>value</b>): that is what keys are designed for.
</p>
<pre><code data-language="lua">-- EXAMPLE OF GOOD CODE

local RestrictedTeams = {
	[TEAM_COOK]=true,
	[TEAM_CITIZEN]=true,
	[TEAM_MOB]=true
}

local AllowedVehicles = {
	prop_vehicle_jeep = true,
	prop_vehicle_airboat = true,
	prop_vehicle_custom1 = true,
	prop_vehicle_custom4 = true,
	prop_vehicle_custom5 = true
}

hook.Add( &quot;CanPlayerEnterVehicle&quot;, &quot;restrict vehicles&quot;, function( ply, veh )
	if RestrictedTeams[ply:Team()] then
		if not AllowedVehicles[veh:GetClass()] then
			return false
		end
	end
end )</code></pre>
<p>We just check the value inside the table directly by using a key! If the value is <b>true</b> then the key is in the table, otherwise it is <b>nil</b>, which is equivalent to <b>false</b> in a condition. This process is very inexpensive and it is worth it.
</p><p>This example uses tables containing keys that are numbers or strings, but they also can be entities, vectors, angles, etc.
</p>
<h2> <span class="mw-headline" id="Identical_keys"> Identical keys </span></h2>
<p>Stay aware from something though: objects can have identical values but still be distinct!
</p>
<pre><code data-language="lua">local angle1 = Angle( 90,0,0 )
local angle2 = Angle( 90,0,0 )
print( &quot;angles are same (1):&quot;, ( angle1==angle2 ) )
angle2.p = 180
print( &quot;angles are same (2):&quot;, ( angle1==angle2 ) )
--[[ Output:
angles are same (1):	true
angles are same (2):	false
]]</code></pre>
<p>Despite these angles being identical, they are 2 distinct objects in memory as you can see!
</p>
<pre><code data-language="lua">local vector1 = Vector( 100,0,0 )
local vector2 = Vector( 100,0,0 )

local TestTable = {}
TestTable[vector1]=true
TestTable[vector2]=true

for vector in pairs( TestTable ) do
	print( &quot;vector is&quot;, vector )
end
--[[ Output:
vector is	100	0	0
vector is	100	0	0
]]</code></pre>
<p>For instance, identical <a href="/page/Category_colon_number" title="Category:number">numbers</a>, <a href="/page/Category_colon_string" title="Category:string">strings</a> and <a href="/page/Category_colon_boolean" title="Category:boolean">booleans</a> are always considered as the same. But <a href="/page/Category_colon_function" title="Category:function">functions</a>, <a href="/page/Category_colon_table" title="Category:table">tables</a>, <a href="/page/Category_colon_Vector" title="Category:Vector">Vectors</a>, <a href="/page/Category_colon_Angle" title="Category:Angle">Angles</a> and <b>NULL </b><a href="/page/Category_colon_Entity" title="Category:Entity">Entitys</a> can seem identical while actually being distinct in memory.
</p>
<pre><code data-language="lua">local function1 = function()
	print( &quot;hello world&quot; )
end
local function2 = function()
	print( &quot;hello world&quot; )
end

print( function1 )
print( function2 )
--[[ Output:
function: 0x30afbb60
function: 0x30afde20
]]</code></pre>


