<div class="function_line">
<span class="server" title="Server">&#160;</span>hammer.SendCommand( <span class="function_args"></span> ) </div><div class="gmodwiki_useful_links"><a rel="nofollow" class="external text" href="https://github.com/Facepunch/garrysmod/search?utf8=âœ“&amp;q=hammer.SendCommand">Search on GitHub</a> - <a href="/page/Special:WhatLinksHere/hammer/SendCommand" title="Special:WhatLinksHere/hammer/SendCommand">What links here?</a></div>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Description"><span class="tocnumber">1</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-1"><a href="#Arguments"><span class="tocnumber">2</span> <span class="toctext">Arguments</span></a>
<ul>
<li class="toclevel-2"><a href="#List_of_commands"><span class="tocnumber">2.1</span> <span class="toctext">List of commands</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Returns"><span class="tocnumber">3</span> <span class="toctext">Returns</span></a></li>
<li class="toclevel-1"><a href="#Examples"><span class="tocnumber">4</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2"><a href="#Example"><span class="tocnumber">4.1</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Description">Description</span></h1>
<p>Sends command to Hammer, if Hammer is running with the current map loaded.
</p>
<h1 class="first_arg"> <span class="mw-headline" id="Arguments">Arguments</span></h1>
<div class="argument">
<p><span class="arg_number"></span> <span class="arg_chunk"><a href="/page/Category_colon_string" title="Category:string">string</a> cmd</span>
</p>
<div style="margin-left: 32px;">
<p>Command to send including arguments
</p><p>All commands are in the format "command var1 var2 etc"<br /><br />
All commands that pick an entity with x y z , must use the exact position including decimals. i.e. -354.4523 123.4 -1224.325452 <br /><br />
</p>
<h2> <span class="mw-headline" id="List_of_commands">List of commands</span></h2>
<p><b>"session_begin mapName mapVersion"</b> - Starts a hammer edit, locking the editor. mapName is the current map without path or suffix, mapVersion is the current version in the .vmf file<br /><br />
<b>"session_end"</b> - Ends a hammer edit, unlocking the editor.<br /><br />
<b>"map_check_version mapName mapVersion"</b> - This only works after session_begin, so you'd know the right version already and this only returns ok, this function is apparently useless<br /><br />
<b>"entity_create entityClass x y z"</b> - Creates an entity of entityClass at position x y z <br /><br />
<b>"entity_delete entityClass x y z"</b> - Deletes an entity of entityClass at position x y z <br /><br />
<b>"entity_set_keyvalue entityClass x y z "key" "value""</b> - Set's the KeyValue pair of an entity of entityClass at x y z. The Key name and Value String must be in quotes.<br /><br />
<b>"entity_rotate_incremental entityClass x y z incX incY incZ"</b> - Rotates an entity of entityClass at x y z by incX incY incZ<br /><br />
<b>"node_create nodeClass nodeID x y z"</b> - Creates an AI node of nodeClass with nodeID at x y z you should keep nodeID unique or you will have issues<br /><br />
<b>"node_delete nodeID"</b> - Deletes node(s) with nodeID, this will delete multiple nodes if they have the same nodeID<br /><br />
<b>"nodelink_create startNodeID endNodeID"</b> - Creates a link between AI nodes startNodeID and endNodeID<br /><br />
</p>
<b>"nodelink_delete startNodeID endNodeID"</b> - Removes a link between AI nodes startNodeID and endNodeID<br /><br /></div>
</div>
<h1 class="first_ret"> <span class="mw-headline" id="Returns">Returns</span></h1>
<div class="return" style="counter-increment: returns;">
<p><span class="ret_number" style="counter-increment: returns -1;"></span> <span class="ret_chunk"><a href="/page/Category_colon_string" title="Category:string">string</a></span>
</p>
<div style="margin-left: 32px;">
<p>Returns "ok" if command succeeded otherwise returns "badcommand".<br /><br />
</p>
<b>All changes only happen in hammer, there is *NO* in game representation/feedback</b></div>
</div>
<h1 class="first_example"> <span class="mw-headline" id="Examples">Examples</span></h1>
<h2 class="examples_number"> <span class="mw-headline" id="Example">Example</span></h2>
<p>A hammer function library I wrote while testing all these functions.
</p><p>Please feel free to use this library as-is or with modification.
</p>
<pre><code data-language="lua">if (&#160;!SERVER) then return end
-- Hammer Editor Lua Library
-- By Malcolm Greene Jr (Fantym420)
 
-- Allows easy access to the hammer editor commands from lua code
-- All commands return ok if they worked and badcommand if they don't
-- All changes only show up in hammer, so if you want to see stuff in game you must
-- write your own ghost entites and such.

hammerLib = {}
hammerLib.mapName = game.GetMap() -- Get the map name
hammerLib.vBSPMapVer = game.GetMapVersion() -- This is the vbsp map version, we need the vmf map version
hammerLib.mapVer = hammerLib.vBSPMapVer -- place holder value findGoodVer will find the current vmf version via trial and error

-- returns a vector string with spaces the way hammer likes it
function hammerLib.vectorToString(vec)

	return tostring(vec.x) .. &quot; &quot; .. tostring(vec.y) .. &quot; &quot; .. tostring(vec.z)

end

-- tries to start a session using the current version, if it fails it tries the next
-- if it can't find it in 20 tries you should probably compile your map before edititng more
function hammerLib.findGoodVer()
	
	local verInc = 0
	local result = &quot;&quot;
	
	for verInc = 0, 20 do 
	
		hammerLib.mapVer = hammerLib.vBSPMapVer + verInc
		
		result = hammerLib.startSession()
		
		if result == &quot;ok&quot; then
			break
		end
		
		if verInc == 20 then
			print(&quot;Good Version Not Found, Please Re-Compile your map!!!&quot;)
		end
	end
	
	hammerLib.endSession()
	
end

-- simple wrapper for hammer.SendCommand so that I could print the debug info
-- un-comment the prints to see the command strings and results in console
function hammerLib.runCommand(cmd)
	
	local result = &quot;&quot;
	--print(&quot;running &quot; .. cmd)
	result = hammer.SendCommand(cmd)
	--print(cmd .. &quot; result: &quot; .. result)
	return result
	

end

-- Always ran when starting an edit
-- This locks hammer until you issue the session_end command
function hammerLib.startSession()
	
	local cmd = &quot;session_begin &quot; .. hammerLib.mapName .. &quot; &quot; .. hammerLib.mapVer
	
	return hammerLib.runCommand(cmd)
	
end

-- Ends the session unlocking hammer
function hammerLib.endSession()
	
	local cmd = &quot;session_end&quot;

	return hammer.SendCommand(cmd)
	
end

-- useless function, it will return ok if you give it a good name and version
-- however to run it you must already have a good version because you ran session_start
-- implemented here for thoroughness, if you give it no variables it will just use the stored info.
function hammerLib.mapCheckVersion(mcName, mcVer)
	
	mcName = mcName or hammerLib.mapName
	mcVer = mcVer or hammerLib.mapVer
	local cmd = &quot;map_check_version &quot; .. mcName .. &quot; &quot; .. mcVer
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- this creates an entity of type entityClass at the given position
--  I believe this only works with point entites seeing as there is no tie to brush command
function hammerLib.entityCreate(entityClass, entityPos)
	
	if (entityClass == nil) or (entityPos == nil) then return end
	local cmd = &quot;entity_create &quot; .. entityClass .. &quot; &quot; .. hammerLib.vectorToString(entityPos)
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- this deletes an entity of type entityClass at entityPos
-- NOTE: must be entities **EXACT** position, decimals and all or it fails
function hammerLib.entityDelete(entityClass, entityPos)
	
	if (entityClass == nil) or (entityPos == nil) then return end
	local cmd = &quot;entity_delete &quot; .. entityClass .. &quot; &quot; .. hammerLib.vectorToString(entityPos)
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- Set's a Key/Value pair on entity of type entityClass at entityPos
-- NOTE: must be entities **EXACT** position, decimals and all or it fails
function hammerLib.entitySetKeyValue(entityClass, entityPos, key, value)
	
	
	if (entityClass == nil) or 
	   (entityPos == nil) or
	   (key == nil) or
	   (value == nil) then return end
	   
	local cmd = &quot;entity_set_keyvalue &quot; .. entityClass .. &quot; &quot; .. hammerLib.vectorToString(entityPos) .. &quot; \&quot;&quot; .. key .. &quot;\&quot; \&quot;&quot; .. value .. &quot;\&quot;&quot;
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end
-- this will rotate an entity of type entityClass(string) at entityPos(vector) by rotationInc(vector)
-- NOTE: must be entities **EXACT** position, decimals and all or it fails
function hammerLib.entityRotateIncremental(entityClass, entityPos, rotationInc)
	
	if (entityClass == nil) or (entityPos == nil) then return end
	local cmd = &quot;entity_rotate_incremental &quot; .. entityClass .. &quot; &quot; .. hammerLib.vectorToString(entityPos) .. &quot; &quot; .. hammerLib.vectorToString(rotationInc)
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- This creates a node of type nodeClass with an ID of nodeID at nodePos
-- keep nodeID unique, if you don't and you use node_delete, it deletes all nodes with the given id
function hammerLib.nodeCreate(nodeClass, nodeID, nodePos)
	
	if (nodeClass == nil) or (nodeID == nil) or (nodePos == nil) then return end
	local cmd = &quot;node_create &quot; .. nodeClass .. &quot; &quot; .. nodeID .. &quot; &quot; .. hammerLib.vectorToString(nodePos)
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end
-- deletes node(s) with the given nodeID, however if there are more than one node with the nodeID all 
-- are deleted
function hammerLib.nodeDelete(nodeID)
	
	if (nodeID == nil) then return end
	local cmd = &quot;node_delete &quot; .. nodeID
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
end

-- This creates a link between two nodes, not sure if there's a limit no number of links
-- so far it does at least 2 per node
function hammerLib.nodeLinkCreate(node1ID, node2ID)
	
	if (node1ID == nil) or (node2ID == nil) then return end
	local cmd = &quot;nodelink_create &quot; .. node1ID .. &quot; &quot; .. node2ID
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- This deletes a connection between two nodes
function hammerLib.nodeLinkDelete(node1ID, node2ID)
	
	if (node1ID == nil) or (node2ID == nil) then return end
	local cmd = &quot;nodelink_delete &quot; .. node1ID .. &quot; &quot; .. node2ID
	local result = &quot;&quot;
	hammerLib.startSession()
	result = hammerLib.runCommand(cmd)
	hammerLib.endSession()
	
	return result
	
end

-- All loaded, run findGoodVer to store the current vmf version
hammerLib.findGoodVer()</code></pre>
<p><br />
</p>


